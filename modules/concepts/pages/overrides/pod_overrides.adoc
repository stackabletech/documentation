= Pod overrides

WARNING: Overriding certain aspects of the Pods can lead to faulty clusters. Pod overrides should only be used as a last resort!

For a role or role group, at the same level of `config`, you can specify `podOverrides` for any of the attributes you can configure on a Pod.

An example for an HDFS clusters looks as follows:

[source,yaml]
----
apiVersion: hdfs.stackable.tech/v1alpha1
kind: HdfsCluster
metadata:
  name: simple-hdfs
spec:
  nameNodes: # change to your your role
    config: # [..]
    podOverrides: # on role level
      spec:
        tolerations:
          - key: "key1"
            operator: "Equal"
            value: "value1"
            effect: "NoSchedule"
    roleGroups:
      default:
        config: # [..]
        podOverrides: # on rolegroup level, takes precedence over the ones specified at role level
          metadata:
            labels:
              my-custom-label: super-important-label
        replicas: 1
----

The `podOverrides` can be any valid `PodTemplateSpec` (which means every property that you can set on a regular Kubernetes Pod).

The priority of how to construct the final Pod submitted to Kubernetes looks as follows (low to high):

1. PodTemplateSpec calculated by operator
2. PodTemplateSpec given in role level `podOverrides`
3. PodTemplateSpec given in rolegroup level `podOverrides`

Each of these are combined top to bottom using a deep merge.
The exact merge algorithm is described in the https://arnavion.github.io/k8s-openapi/v0.18.x/k8s_openapi/trait.DeepMerge.html[k8s-openapi docs], which basically tries to mimic the way Kubernetes merges patches onto objects.
