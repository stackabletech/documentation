= [Logging and Log Aggregation Architecture]
Felix Hennig <felix.hennig@stackable.tech>
v0.1, 2022-10-26
:status: [draft]

* Status: {status}
* Deciders: Stackable Team
* Date: 2022-10-26

Technical Story: https://github.com/stackabletech/issues/issues/202, https://github.com/stackabletech/issues/issues/261

== Context and Problem Statement

// Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.

Context: As of the day of writing, every product logs in its own log format to stdout. Logs cannot be viewed centrally, log levels cannot be set for individual parts of applications or across multiple products at once.

// TODO: Are operator logs out of scope or in scope?

== Decision Drivers

* **identical configuration** - All product logs should be configurable in the same way, no matter their underlying logging framework (log4j, logback, Python logging, etc.).
// TODO: Open question: Which properties do we support?
* **easily configured sinks** - A log sink (i.e. elasticsearch) should only be configured in a single place for the whole platform (not in every product instance).
* **transport security** - Logs should transmitted with encryption/TLS.
* **custom overrides** - The log format, aggregator and sink should be substitutable by the user.

== Considered Options

// TODO: Why vector?

=== Log Retrieval

* Parse plaintext vs. provide structured logs (i.e. json)
* Retrieve logs from stdout vs. from file

=== Log Aggregation Architecture

* Aggregator vs. no aggregator
* DaemonSet vs. Sidecar
* Sink: OpenSearch vs. ???

== Decision Outcome

We chose to provide **plaintext logs on stdout** and *structured logs on file**. For the architecture, we chose to deploy the agent as a **sidecar** and **use an aggregator**. We chose to provide **OpenSearch** as a default Sink for logs.

=== Positive Consequences <!-- optional -->

* [e.g., improvement of quality attribute satisfaction, follow-up decisions required, …]
* …

=== Negative Consequences <!-- optional -->

* [e.g., compromising quality attribute, follow-up decisions required, …]
* …

== Pros and Cons of the Options

=== Plaintext vs. Structured Log; Stdout vs File

* Logs on stdout are still useful, because you can read them with kubectl or k9s to debug things. In that case, they should be plain, so they are easy to read for a human.
* Logs parsed by the aggregator are differt.
  * Parsing plaintext logs can be tricky, because regexes are needed
  * Using structured logs is much more robust.
* Some products _need_ to log to file, because of _reasons_. They either cannot be configured differently (which ones?), have logs confidential logs that shouldn't go do stdout, or ...
* File logs can be structured, as they are not meant to be read by a human.

=== Aggregator vs. no Aggregator

[example | description | pointer to more information | …] <!-- optional -->

* Good, because [argument a]
* Good, because [argument b]
* Bad, because [argument c]
* … <!-- numbers of pros and cons can vary -->

=== Sidecar vs. DaemonSet

[example | description | pointer to more information | …] <!-- optional -->

* Good, because [argument a]
* Good, because [argument b]
* Bad, because [argument c]
* … <!-- numbers of pros and cons can vary -->

=== Sinks

[example | description | pointer to more information | …] <!-- optional -->

* Good, because [argument a]
* Good, because [argument b]
* Bad, because [argument c]
* … <!-- numbers of pros and cons can vary -->

== Links <!-- optional -->

* [Link type] [Link to ADR] <!-- example: Refined by [ADR-0005](0005-example.md) -->
* … <!-- numbers of links can vary -->