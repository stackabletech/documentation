= [Resource Status]
Sebastian Bernauer <sebastian.bernauer@stackable.tech>
v0.1, 2023-02-28
:status: draft

* Status: {status}
* Deciders:
** Malte Sander
** Razvan Mihai
* Date: 2023-02-28

Technical Story: https://github.com/stackabletech/issues/issues/343

== Context and Problem Statement

// Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.

Resources managed by operators must offer a consistent and easy interface to query their availabilty. This is important for users to determine if the resource is functioning properly as well as for automated processes to ensure that flows or pipelines reach certain states and can continue.

Possible predefined condition types:
* Available (OpenShift)
* Progressing (OpenShift)
* Degraded (OpenShift)
* Upgradable (OpenShift)
* Paused (Stackable)
* Stopped (Stackable)

Possible condition states (strings):
* True
* False
* Unknown

== Decision Drivers

The status field should be set and maintained for cluster resources as well as sub-resources (ex. `ZNode`, `SupersetDB`, etc.).

Must haves for cluster resources and sub-resources:
- Status string field to allow easy programatic query of the resource state (Available, Degraded, Stopped, Paused, ...).
- Status conditions as a generic and easy way to check the availability of the cluster and transition history.

Must have for cluster resources:
- Deployed product version. Used for in-place product upgrades/downgrades/migrations.
  
Nice to have based on product functionality:
- task/qurey load status (ram, cpu)
- disk pressure
- security status (tls on/off)
- accessability (external, internal k8s cluster only, hybrid)


== Considered Options

=== Set Status Conditions

The status conditions can be set in a generic way by querying the sub-resources of a cluster resource and applying logical opertors to compute the cluster status. For example, the Superset operator, queries the status of all StatefulSets, DB jobs, etc. and computes the cluster conditions based on all of them. 

If all sub-resources have a corresponding "Available" type with status `True` then, the custer will also have a condition of type  "Available" and status `True`. If any of the sub-resources are not `Available`, then the cluster status will reflect this by setting the condition `Degraded` to status `True`


OpenShift predefined condition types: https://github.com/openshift/api/blob/b1bcdbc3/config/v1/types_cluster_operator.go#L123-L140
Kubernetes Pod conditions: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions

QUESTION: should depending services be considered for status checks ? For example, should the Superset operator check that Druid services function properly ?

==== Pros

* Implementaion detail: reuse `ClusterResources` from the `operator-rs` framework as much as possible and have a generic way to update cluster status.
* Non-breaking CRD changes needed to add conditions.
* Transparent and easy to understand. Failure messages can be propagated from sub-resources hat have problems.


==== Cons

* It completely relies on Kubernetes resource status fields without querying the actual products. This assumes that liveliness probes and other checks htat Kubermetes performs, mirror the true product status.
* It requires that all resource dependencies run inside the Kubernetes cluster. For example, if Superset is configured with a Druid connection outside the Kubernetes cluster, the `Available` confition of the connection will have a status of `Unknown`.


[source,yaml]
----
status:
  conditions:
    - type: Available
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      message: "UI and Postgres DB running"
    - type: Degraded
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      reason: "DruidConnection failed. <Optional: Druid degraded message>"
    - type: Progressing
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      message: "New replicas starting."
    - type: Upgradable
      status: "Unknown"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
    - type: Paused
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      message: "User requested reconcide pause."
----

Second example:

[source,yaml]
----
status:
  conditions:
    - type: Available
      status: "False"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2018-01-01T00:00:00Z
      message: "No Pods running."
    - type: Stopped
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      reason: "User requested reconcile stop."
----

=== Set Status Custom Fields and Conditions

Most custom fields are set by querying the products directly. One exception is the deployed product version.

==== Pros

* Fine graned status information
* More reliable status information that is queried directly from the operated product and dependencies
* Products can run inside and outside the Kubernetes cluster

==== Cons

* Complexity and specificity of the implementation. Operators must implement product network protocols and metadata structures to be able to communicate with the products.
* Hard to maintain across product versions.
* Each new sub-resource requires additional code and dependencies.


Example:

[source,yaml]
----
status:
  deployedVersion: 1.2.3
  authentication: mtls
  conditions:
    - type: Available
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      message: "UI and Postgres DB running"
    - type: Degraded
      status: "True"
      lastProbeTime: 2023-02-28T14:02:00Z
      lastTransitionTime: 2023-02-28T12:00:00Z
      message: "Druid connection failed. Druid client message: Unauthorized."
----


== Decision Outcome

TODO
