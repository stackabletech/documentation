= ADRx: Product Image Versioning
Teo Klestrup Röijezon <teo.roijezon@stackable.de>
v0.1, dd.mm.yyyy
:status: draft

* Status: {status}
* Deciders: [list everyone involved in the decision] <!-- optional -->
* Date: [YYYY-MM-DD when the decision was last updated] <!-- optional -->

Technical Story: [description | ticket/issue URL] <!-- optional -->

== Context and Problem Statement

Currently, we publish all products as Docker images following the template
`docker.stackable.tech/stackable/$PRODUCT:$PRODUCT_VERSION-stackable$IMAGE_VERSION`, as well as
`docker.stackable.tech/stackable/$PRODUCT:$PRODUCT_VERSION-stackable$IMAGE_SEMVER_MAJOR`.

In theory, a given Operator version depends on some SemVer range of `image_version` (for example `^1.3.0`, which
expands to `>=1.3.0 <2.0.0`).

In practice however, Docker tags are opaque, which prevents us from actually specifying this anywhere. Instead, we can only
express the range `^N.0.0` (`>=N.0.0 <N+1.0.0`), depending on the `-stackable$IMAGE_SEMVER_MAJOR` tag. This works
OK for spinning up new clusters, but means that existing clusters may keep running old image versions even after upgrading to new
(incompatible) Operator versions. The cluster may also end up in a mixed environment if a replica gets deployed to a new node after
a new image version has been released.

== Decision Drivers

* The cluster's stable state should ensure that all members of a given `ProductCluster` are running the same image version
* The cluster should always be (approaching) running an image version that is compatible with the running operator
* We should try to limit the number of maintained image version "tracks" for each product
* Customers may want to lock down the image version that they are running
* Old versions of operators should keep working and deploying images that they are compatible with

== Considered Options

* Synchronize image versions in lockstep with operator versions
* Bump major image version for every change that operators depend on
* Resolve Docker tags to image hashes in operator
* Resolve SemVer ranges to Docker tags in operator
* Configure `imagePullPolicy: Always` in deployed pods

== Decision Outcome

Chosen option: "[option 1]", because [justification. e.g., only option, which meets k.o. criterion decision driver | which resolves force force | … | comes out best (see below)].

=== Positive Consequences <!-- optional -->

* [e.g., improvement of quality attribute satisfaction, follow-up decisions required, …]
* …

=== Negative Consequences <!-- optional -->

* [e.g., compromising quality attribute, follow-up decisions required, …]
* …

== Pros and Cons of the Options

=== Synchronize image and operator versions

Each operator version hard-codes exactly one image version that it supports, and we release new product images for each operator images.

This would likely mean moving the product Dockerfiles into their corresponding operators' repositories.

* Good, because it centralizes the information about which versions are supported into each operator's repository
* Good, because upgrades are predictable for the user, "upgrading the operator upgrades the cluster" is easy to explain and teach
* Good, because image tags are stable and immutable once released
* Bad, because we end up storing a lot of duplicate Docker images
  * We could share the Docker layers to lessen this impact dramatically, but that would require rearchitecting our CI
* Bad, because it increases the overhead of doing operator or image releases
* Bad, because old operator versions will keep deploying older image versions than they may technically be compatible with

=== Bump major image version for every change that operators depend on

Keep the current system as-is, but essentially merge major and minor versions in SemVer.

* Good, because it changes as little as possible about the infrastructure
* Bad, because it allows patch versions to drift apart drift in a running cluster
* Bad, because it forces us to maintain many more image version "tracks"
* Bad, because old operator versions will keep deploying older image versions than they may technically be compatible with
* Bad, because existing operators will invisibly switch which (patch-level) image version they deploy without user action

=== Resolve Docker tags to image hashes in operator

The operator resolves the SemVer-major Docker tag into a concrete image hash during reconciliation.

* Good, because we preserve SemVer for image versions
* Good, because we prevent version drift between cluster replicas
* Good, because existing operators will upgrade as far as they are compatible
* Bad, because it increases the complexity of the operators
* Bad, because it slows down reconciliation
* Bad, because existing operators will switch which (minor-level) image version they deploy without user action
* Bad, because we don't have a good trigger for when new image versions are released
* Bad, because on-prem registry mirrors may be outdated and serve incompatible versions

=== Resolve SemVer ranges in operator

The operator resolves a hard-coded SemVer range into a Docker tag and concrete image hash during reconciliation.

* Good, because we preserve SemVer for image versions
* Good, because we prevent version drift between cluster replicas
* Good, because existing operators will upgrade as far as they are compatible
* Good, because we can fail with a reasonable error message if no compatible image is available
* Bad, because it increases the complexity of the operators even further
* Bad, because it slows down reconciliation
* Bad, because existing operators will switch which (minor-level) image version they deploy without user action
* Bad, because we don't have a good trigger for when new image versions are released
* Bad, because on-prem registry mirrors may not have whatever API or metadata we need to perform this resolution

=== Configure `imagePullPolicy: Always` in deployed pods

The operator always sets the `imagePullPolicy: Always` field in pods, forcing the Kubelets to always re-pull
the image every time the Pod is started.

* Good, because it's a minimal change
* Bad, because it doesn't restart running pods, even if they are incompatible
  * This means that it doesn't solve the original problem at all
* Bad, because it allows minor versions to drift apart drift in a running cluster
* Bad, because it prevents any restarts while the Docker registry is unavailable
* Bad, because existing operators will invisibly switch which (minor-level) image version they deploy without user action
* Bad, because on-prem registry mirrors may be outdated and serve incompatible versions
