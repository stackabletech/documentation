= ADR0XX: 
Felix Hennig <felix.hennig@stackable.tech>
v0.1, 2023-09-19
:status: draft

* Status: {status}
* Deciders: TBD
* Date: 2023-09-19

Technical Story: https://github.com/stackabletech/issues/issues/431

== Context and Problem Statement

OIDC is a widespread authentication mechanism. Keycloak is also widespread as a self-hosted, internal identity provider. Gaia-X also uses OIDC internally to authenticate users.

How can we support OIDC on the Stackable Data Platform, to integrate with existing OIDC identity providers that clients may be running?

For LDAP, we wrote an AuthenticationClass, it would make sense to develop one or multiple AuthenticationClasses for OIDC in general, or specific providers.

Problem: Which settings to we want to have in an authenticationclass? Do we want a generic "OIDC" authenticationclass? Maybe we can habe a "Keycloak" class which would be easier for the user but not as generic.

=== Context: Product configs we need to support with the AuthenticationClass

We built a demo that works with Superset, Trino and Druid. From there we know about the relevant config settings.

The OIDC spec defines a discovery endpoint at which all further configuration can be read.

Additionally, every client needs to be registered and gets its own client ID and secret.

==== Trino

```
web-ui.authentication.type: oauth2
http-server.authentication.oauth2.client-id: trino
http-server.authentication.oauth2.client-secret: ${ENV:TRINO_CLIENT_SECRET}
http-server.authentication.oauth2.issuer: http://${ENV:KEYCLOAK_ADDRESS}/realms/master
http-server.authentication.oauth2.scopes: openid
```

==== Druid

```
# pac4j authenticator
druid.auth.authenticator.pac4j.type: pac4j
druid.auth.authenticator.pac4j.authorizerName: OpaAuthorizer
# pa4j common config
druid.auth.pac4j.cookiePassphrase: '${env:DRUID_COOKIE_PASSPHRASE}'
# OIDC common config
druid.auth.pac4j.oidc.clientID: druid
druid.auth.pac4j.oidc.clientSecret: '{"type":"environment","variable":"DRUID_CLIENT_SECRET"}'
druid.auth.pac4j.oidc.discoveryURI: '${env:KEYCLOAK_DISCOVERY_URL}'
```

==== Superset

Does not support reading an OIDC discovery URL but needs: API base URL, auth URL, token URL. Also the Superset client wants the _email_, _profile_ and _oidc_ scope. We _could_ also implement fab-oidc support for Superset, so it has proper OIDC support. Needs to be maintained though.

The auth and token URL are supplied at the `.well-known` endoint, but the base URL is not. Could maybe be guessed from the other endpoints?

```
{ 
    'name': 'keycloak',
    'icon': 'fa-key',
    'token_key': 'access_token',
    'remote_app': {
    'client_id': 'superset',
    'client_secret': f'{os.environ.get("SUPERSET_CLIENT_SECRET")}',
    'api_base_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect',
    'client_kwargs': {
        'scope': 'email profile openid'
    },
    'access_token_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/token',
    'authorize_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/auth',
    'request_token_url': None,
    },
}
```

=== Context: Common authentication servers that users might want to connect to

These are some authentication servers that users might be using.

* Keycloak
* Auth0
* ADFS
* Dex
* Okta

In general it can be expected that this service would already be running at the user.

== Decision Drivers

... ?

* Different OIDC providers supported?
* Configuration should be simple, with minimal info required by the user.
* Every connecting product should have its own client ID and client secret. The client secret should be stored in a k8s secret.
* An AuthenticationClass should be defined

== Considered Options

Every software that wants to use an OIDC provider for logging in needs to be registered as a client with the identity provider. How is this managed? can we even do a generic config like that?

=== 1. Make a generic OIDC config

The AuthenticationClass should contain the root/issuer URL. From there with the `<issuer-url>/.well-known/configuration-configuration`, relevant configuration can either be derived or additional information retrieved.

For the client ID and client secret, additional information needs to be set in the ProductCluster resource (where?)

Pro:

* This is the way it is intended to work

Con:

* For i.e. Superset we first need to make an API call and maybe even guess some information


=== 2. make an OIDC and OAuth2 class

For Superset, use OAuth2, for the rest use OIDC. Annoying for the user because the have to maintain both.

=== 3. Auth-server specific configs

i.e. for Keycloak. We just ask the user to provide the address and version of their keycloak. And then based on that we can calculate all the relevant settings.

This is nice, because we need different settings for different products. For example, superset needs three different URLs. Trino needs to base URL auf the realm. Druid needs the discovery URL.

This is a bit similar to how we treat SQL databases.
