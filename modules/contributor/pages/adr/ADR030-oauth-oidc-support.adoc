= ADR0XX: 
Felix Hennig <felix.hennig@stackable.tech>
v0.2, 2023-11-14
:status: draft

* Status: {status}
* Deciders:
** Sebastian Bernauer
** Malte Sander
** Sascha Lautenschläger
** Natalie Röijezon
** Razvan Mihai
** Felix Hennig
* Date: 2023-11-14

Technical Story: https://github.com/stackabletech/issues/issues/431

== Problem Statement

OIDC is a widespread authentication mechanism, supported by most modern data products as well as identity providers. OIDC is also used inside the Gaia-X ecosystem. Keycloak is also widespread as a self-hosted, internal identity provider. Just as with LDAP, we expect users to already have an identiy provider running; deploying an identity provider is out of scope of the design.

We want to support OIDC as an authentication mechanism on the Stackable Data Platform, allowing users to configure their already existing identity provider in our AuthenticationClass mechanism.

Problems include the slightly different ways of configuring products; deciding on how OIDC clients are configured and how to provide client credentials.

== Context

Useful information to consider in the decision.

=== OIDC Clients and product-client-mappings

To configure a product to use ODIC, it needs information about where to find the OIDC provider (typically the URL of the discovery endpoint), as well as client credentials to authenticate with the provider.
The connection information is generic and shared between all clients, but the crendentials are product specific.

It is best practice to have one client per connecting product.
This allows the user to define exactly from which hosts the client can be used, as well as valid redirect URLs.
Sometimes a separate client per product is also technically required, because a product might require specific configuration for a particular product, i.e. rewriting claims.

This leaves multiple different mappings from products and product instances to configured clients; making these use cases easy to configure is an important consideration.

* One single client for all product connections (useful for debugging, or as an initial test setup; might not always be technically feasible depending on the products)
* One client per _product_ but not per _instance_ - i.e. running 5 NiFi instances and 5 Trinos, but with 2 clients: one for NiFi and one for Trino. This might be a good setup in larger teams, where new product instances get spun up all the time and the team managing the OIDC provider (and clients) is different from the team running the data products.
* One client per _product instance_: The finest granularity, every instance gets its own client.

=== Context: Product configs we need to support with the AuthenticationClass

Below are example configurations for Superset, Trino and Druid, which we built for the `keycloak-opa-poc` Stack. The AuthenticationClass needs to contain information to generate these configs.

==== Trino

```
web-ui.authentication.type: oauth2
http-server.authentication.oauth2.client-id: trino
http-server.authentication.oauth2.client-secret: ${ENV:TRINO_CLIENT_SECRET}
http-server.authentication.oauth2.issuer: http://${ENV:KEYCLOAK_ADDRESS}/realms/master
http-server.authentication.oauth2.scopes: openid
```

==== Druid

```
# pac4j authenticator
druid.auth.authenticator.pac4j.type: pac4j
druid.auth.authenticator.pac4j.authorizerName: OpaAuthorizer
# pa4j common config
druid.auth.pac4j.cookiePassphrase: '${env:DRUID_COOKIE_PASSPHRASE}'
# OIDC common config
druid.auth.pac4j.oidc.clientID: druid
druid.auth.pac4j.oidc.clientSecret: '{"type":"environment","variable":"DRUID_CLIENT_SECRET"}'
druid.auth.pac4j.oidc.discoveryURI: '${env:KEYCLOAK_DISCOVERY_URL}'
```

==== Superset

Does not support reading an OIDC discovery URL but needs: API base URL, auth URL, token URL. Also the Superset client wants the _email_, _profile_ and _oidc_ scope. We _could_ also implement fab-oidc support for Superset, so it has proper OIDC support. Needs to be maintained though.

The auth and token URL are supplied at the `.well-known` endoint, but the base URL is not. Could maybe be guessed from the other endpoints?

```
{ 
    'name': 'keycloak',
    'icon': 'fa-key',
    'token_key': 'access_token',
    'remote_app': {
    'client_id': 'superset',
    'client_secret': f'{os.environ.get("SUPERSET_CLIENT_SECRET")}',
    'api_base_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect',
    'client_kwargs': {
        'scope': 'email profile openid'
    },
    'access_token_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/token',
    'authorize_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/auth',
    'request_token_url': None,
    },
}
```

=== Common authentication servers that users might want to connect to

For testing (and also in the Gaia-X context) we use _Keycloak_ as the identity provider, but our design should not be Keycloak specific; it should work with -- ideally -- all OIDC providers.
Other common (and not so common) providers are:

* Auth0
* ADFS
* Dex
* Okta

As mentioned before, we expect the user to already operate the identity provider.

== Decision Drivers

* DRY - don't repeat yourself: information should ideally only be configured in one spot.
* flexible: Different variants of client and product instance mapping should be supported.
* comprehensible: It not require too much documentation to explain how a product configuration is assembled based on the manifests that the user deploys.
* comprehensive: supporting all our existing products (if they support ODIC) as well as all (or most) OIDC providers listed above.
* principle of least surprise: OIDC should be configured in a similar way to LDAP.

== Considered Options

Every software that wants to use an OIDC provider for logging in needs to be registered as a client with the identity provider. How is this managed? can we even do a generic config like that?

=== 1. Make a generic OIDC config

The AuthenticationClass should contain the root/issuer URL. From there with the `<issuer-url>/.well-known/configuration-configuration`, relevant configuration can either be derived or additional information retrieved.

For the client ID and client secret, additional information needs to be set in the ProductCluster resource (where?)

Pro:

* This is the way it is intended to work

Con:

* For i.e. Superset we first need to make an API call and maybe even guess some information


=== 2. make an OIDC and OAuth2 class

For Superset, use OAuth2, for the rest use OIDC. Annoying for the user because the have to maintain both.

=== 3. Auth-server specific configs

i.e. for Keycloak. We just ask the user to provide the address and version of their keycloak. And then based on that we can calculate all the relevant settings.

This is nice, because we need different settings for different products. For example, superset needs three different URLs. Trino needs to base URL auf the realm. Druid needs the discovery URL.

This is a bit similar to how we treat SQL databases.
