= ADR0XX: 
Felix Hennig <felix.hennig@stackable.tech>
v0.2, 2023-11-14
:status: draft

* Status: {status}
* Deciders:
** Sebastian Bernauer
** Malte Sander
** Sascha Lautenschläger
** Natalie Röijezon
** Razvan Mihai
** Felix Hennig
* Date: 2023-11-14

Technical Story: https://github.com/stackabletech/issues/issues/431

== Problem Statement

OIDC is a widespread authentication mechanism, supported by most modern data products as well as identity providers. OIDC is also used inside the Gaia-X ecosystem. Keycloak is also widespread as a self-hosted, internal identity provider. Just as with LDAP, we expect users to already have an identiy provider running; deploying an identity provider is out of scope of the design.

We want to support OIDC as an authentication mechanism on the Stackable Data Platform, allowing users to configure their already existing identity provider in our AuthenticationClass mechanism.

Problems include the slightly different ways of configuring products; deciding on how OIDC clients are configured and how to provide client credentials.

== Context

Useful information to consider in the decision.

=== OIDC Clients and product-client-mappings

To configure a product to use ODIC, it needs information about where to find the OIDC provider (typically the URL of the discovery endpoint), as well as client credentials to authenticate with the provider.
The connection information is generic and shared between all clients, but the crendentials are product specific.

It is best practice to have one client per connecting product.
This allows the user to define exactly from which hosts the client can be used, as well as valid redirect URLs.
Sometimes a separate client per product is also technically required, because a product might require specific configuration for a particular product, i.e. rewriting claims.

This leaves multiple different mappings from products and product instances to configured clients; making these use cases easy to configure is an important consideration.

* One single client for all product connections (useful for debugging, or as an initial test setup; might not always be technically feasible depending on the products)
* One client per _product_ but not per _instance_ - i.e. running 5 NiFi instances and 5 Trinos, but with 2 clients: one for NiFi and one for Trino. This might be a good setup in larger teams, where new product instances get spun up all the time and the team managing the OIDC provider (and clients) is different from the team running the data products.
* One client per _product instance_: The finest granularity, every instance gets its own client.

=== Context: Product configs we need to support with the AuthenticationClass

Below are example configurations for Superset, Trino and Druid, which we built for the `keycloak-opa-poc` Stack. The AuthenticationClass needs to contain information to generate these configs.

==== Trino

```
web-ui.authentication.type: oauth2
http-server.authentication.oauth2.client-id: trino
http-server.authentication.oauth2.client-secret: ${ENV:TRINO_CLIENT_SECRET}
http-server.authentication.oauth2.issuer: http://${ENV:KEYCLOAK_ADDRESS}/realms/master
http-server.authentication.oauth2.scopes: openid
```

==== Druid

```
# pac4j authenticator
druid.auth.authenticator.pac4j.type: pac4j
druid.auth.authenticator.pac4j.authorizerName: OpaAuthorizer
# pa4j common config
druid.auth.pac4j.cookiePassphrase: '${env:DRUID_COOKIE_PASSPHRASE}'
# OIDC common config
druid.auth.pac4j.oidc.clientID: druid
druid.auth.pac4j.oidc.clientSecret: '{"type":"environment","variable":"DRUID_CLIENT_SECRET"}'
druid.auth.pac4j.oidc.discoveryURI: '${env:KEYCLOAK_DISCOVERY_URL}'
```

==== Superset

Does not support reading an OIDC discovery URL but needs: API base URL, auth URL, token URL. Also the Superset client wants the _email_, _profile_ and _oidc_ scope. We _could_ also implement fab-oidc support for Superset, so it has proper OIDC support. Needs to be maintained though.

The auth and token URL are supplied at the `.well-known` endoint, but the base URL is not. Could maybe be guessed from the other endpoints?

```
{ 
    'name': 'keycloak',
    'icon': 'fa-key',
    'token_key': 'access_token',
    'remote_app': {
    'client_id': 'superset',
    'client_secret': f'{os.environ.get("SUPERSET_CLIENT_SECRET")}',
    'api_base_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect',
    'client_kwargs': {
        'scope': 'email profile openid'
    },
    'access_token_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/token',
    'authorize_url': f'http://{os.environ.get("KEYCLOAK_ADDRESS")}/realms/master/protocol/openid-connect/auth',
    'request_token_url': None,
    },
}
```

=== Common authentication servers that users might want to connect to

For testing (and also in the Gaia-X context) we use _Keycloak_ as the identity provider, but our design should not be Keycloak specific; it should work with -- ideally -- all OIDC providers.
Other common (and not so common) providers are:

* Auth0
* ADFS
* Dex
* Okta

As mentioned before, we expect the user to already operate the identity provider.

== Decision Drivers

* DRY - don't repeat yourself: information should ideally only be configured in one spot.
* flexible: Different variants of client and product instance mapping should be supported.
* comprehensible: It not require too much documentation to explain how a product configuration is assembled based on the manifests that the user deploys.
* comprehensive: supporting all our existing products (if they support ODIC) as well as all (or most) OIDC providers listed above.
* principle of least surprise: OIDC should be configured in a similar way to LDAP.

== Currently considered design

During a Hackathon we came up with a design, showcased in this sample configuration:

[source,yaml]
----
apiVersion: authentication.stackable.tech/v1alpha1
kind: AuthenticationClass
metadata:
  name: keycloak
spec:
  provider:
    oidc:
      hostname: "$KEYCLOAK_HOSTNAME"
      port: $KEYCLOAK_PORT
      rootPath: /realms/master
      scopes: [ openid, email, profile ] # User can specify whatever scopes they want, these 3 are recommended for OIDC
      # docs:
      # This is a hint for the products on a best-effort base, most of the products will ignore this value.
      # E.g. Superset Superset uses this to configure the correct claims to extract from the userinfo endpoint as well as a nice icon
      # => We only start with Keycloak in v1, but might extend it in the future
      providerHint: Keycloak # Option<ProviderHint>, None means no hint, just use OIDC as is
      tls:
        verification:
          none: {}
---
apiVersion: trino.stackable.tech/v1alpha1
kind: TrinoCluster
metadata:
  name: trino
spec:
  image:
    productVersion: "414"
    stackableVersion: 23.7.0
  clusterConfig:
    listenerClass: external-unstable
    tls:
      serverSecretClass: tls
    catalogLabelSelector:
      matchLabels:
        trino: trino
    authentication:
      - authenticationClass: keycloak / open-ldap
        oidc: # Option<>
          clientCredentialsSecret: trino-keycloak-client # mandatory (% anonymous client connection), error when AuthClass provider is oidc and this is not set
          extraScopes: [ groups ] # Extra scopes which get merged with the above scopes
        ldap: # Option<>
          bindCredentialsSecretClass: trino-openldap-bind # optional for some products, mandatory for others
          # In the future
          ldapBindUserSecret: trino-openldap-bind
    authorization:
      opa:
        configMapName: opa
        package: trino
  coordinators:
    roleGroups:
      default:
        replicas: 1
  workers:
    roleGroups:
      default:
        replicas: 1
---
apiVersion: v1
kind: Secret
metadata:
  name: trino-keycloak-client
stringData:
  clientId: trino
  clientSecret: "{{ keycloakTrinoClientSecret }}"
----

== Considered alternatives

* A distinct OAuth2 AuthenticationClass: This was considered to make it easier to configure Superset and Airflow, as they do not support ODIC out-of-the-box, but during a spike we found that it was feasible to generate OAuth2 configuration from the OIDC AuthenticationClass.
* Identity provider specific AuthenticationClasses: The idea of having a "Keycloak" class instead of a generic ODIC class was floated, but discarded as it seemed to not have any benefits.
