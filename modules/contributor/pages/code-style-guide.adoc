= Source code style guide

== Long versus abbreviated variable names

We use long (no abbreviated) variables names for function parameters and locally declared variables. Short (even single
letter) variable names are allowed in lambdas (closures) and one-liners. The usage of well-known acronyms like CPU, TLS
or OIDC are allowed.

Examples of *incorrect* code for this rule:

[source,rust]
----
let param = Some("foo");
let buf = &[];

fn func(elems: Vec<String>) {}
----

Examples of *correct* code for this rule:

[source,rust]
----
let parameter = Some("foo");
let buffer = &[];

fn func(elements: Vec<String>) {}

// Closures and one-liners

let length = parameter.map(|p| p.len());

// Well-known acronyms

let oidc_provider = OidcProvider {};
let tls_settings = TlsSettings {};
----

== Captured versus uncaptured format string identifiers

We generally use captured format string identifiers. The identifiers should be concise but not abbreviated.
Mix-and-matching of captured and uncaptured format string identifiers must be avoided.

Examples of *incorrect* code for this rule:

[source,rust]
----
format!("Hello, {}!", "world");
format!("{greeting}, {}!", greeting = "Hello", "world");
----

Examples of *correct* code for this rule:

[source,rust]
----
let greetee = "world";

format!("Hello, {greetee}!");
format!("{greeting}, {greetee}!", greeting = "Hello");
----

We place no restriction on named format string identifiers. Both options below are considered valid.

[source,rust]
----
let greetee = "world";

format!("Hello, {greetee}!");
format!("Hello, {greetee}!", greetee = "world");
----

== Newlines between struct fields and enum variants

We add newlines to struct fields and enum variants when they include additional information like documentation comments
or attributes.

Examples of *incorrect* code for this rule:

[source,rust]
----
struct Foo {
  /// My doc comment for bar
  bar: usize,
  /// My doc comment for baz
  baz: usize,
}

enum Error {
  /// Indicates that we failed to foo.
  #[snafu(display("failed to foo"))]
  Foo,
  /// Indicates that we failed to bar.
  #[snafu(display("failed to bar"))]
  Bar,
  Baz,
}
----

Examples of *correct* code for this rule:

[source,rust]
----
struct Foo {
  /// My doc comment for bar
  bar: usize,

  /// My doc comment for baz
  baz: usize,
}

enum Error {
  /// Indicates that we failed to foo.
  #[snafu(display("failed to foo"))]
  Foo,

  /// Indicates that we failed to bar.
  #[snafu(display("failed to bar"))]
  Bar,
  Baz,
}
----

== Error handling

We use `snafu` for all error handling in library *and* application code. Additionally, we restrict the usage of the
`#[snafu(context(false))]` atrribute on error variants. This ensures that fallible functions need to call `.context()`
to pass the error along.

Examples of *incorrect* code for this rule:

[source,rust]
----
#[derive(thiserror::Error)]
enum Error {
  #[error("failed to read config file")]
  FileRead(#[from] std::io::Error)
}

fn config_file(user: User) -> Result<(), Error> {
  std::fs::read_to_string(user.file_path)?;
}
----

[source,rust]
----
#[derive(Snafu)]
enum Error {
  #[snafu(context(false))]
  FileRead { source: std::io::Error }
}

fn config_file(user: User) -> Result<(), Error> {
  std::fs::read_to_string(user.file_path)?;
}
----

Examples of *correct* code for this rule:

[source,rust]
----
#[derive(Snafu)]
enum Error {
  #[snafu(display("failed to read config file of user {user_name}"))]
  FileRead {
    source: std::io::Error,
    user_name: String,
  }
}

fn config_file(user: User) -> Result<(), Error> {
  std::fs::read_to_string(user.file_path).context(FileReadSnafu {
    user_name: user.name,
  });
}
----

== Error messages

All our error messages must start with a lowercase letter and must not end with a dot. Additionally, critical
(unrecoverable) errors should start with "failed ...". Potentially recoverable errors should start with "unable ...".

Examples of *incorrect* code for this rule:

[source,rust]
----
#[derive(Snafu)]
enum Error {
  #[snafu(display("Foo happened."))]
  Foo,

  #[snafu(display("Bar encountered"))]
  Bar,

  #[snafu(display("arghh baz."))]
  Baz,
}
----

Examples of *correct* code for this rule:

[source,rust]
----
#[derive(Snafu)]
enum Error {
  #[snafu(display("failed to foo"))]
  Foo,

  #[snafu(display("unable to bar"))]
  Bar,
}
----
